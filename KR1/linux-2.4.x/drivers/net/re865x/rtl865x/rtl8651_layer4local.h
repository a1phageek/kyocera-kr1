/////////////////////////////////////////////////////////////////
////
//// This file is to be included only by rtl8651_tblDrvLocal.h
//// This file exists only to split lengthy driver definitions to several organized header files
////
////  !!!Only  put Layer 4 driver specific 
////              1) local data types, 2) #define, and 3)macros 
////        in this file
////
//// Leave all "externs" and functions prototypes to rtl8651_tblDrvlocal.h 
//// If the API or datatype is to be exported outside the driver,
//// Please put it in rtl8651_layer2.h or rtl8651_tblDrv.h 
////
/////////////////////////////////////////////////////////////////

#ifdef RTL8651_TBLDRV_LOCAL_H   //can only be included by rtl8651_tblDrvLocal.h once
#ifndef RTL86561_LAYER4_LOCAL_H
#define RTL86561_LAYER4_LOCAL_H

//Forward declarations
struct ip;
struct rtl_pktHdr;


#define L4_N_LINK_TCP_DATA 2


typedef struct rtl8651_tblDrv_global_s {
	uint32 icmpTimeout;
	uint32 udpTimeout;
	uint32 tcpLongTimeout;
	uint32 tcpMediumTimeout;
	uint32 tcpFastTimeout;
	uint32 tcpFinTimeout;  /* Louis note that it is for Hash2 double-FINed connections only. */
	uint16 l4PortRangeStart, l4PortRangeEnd;
	uint16 l4NaptFindEmptyAsicRetry;
} rtl8651_tblDrv_global_t;

typedef struct rtl8651_tblDrv_naptServerPortEntry_s {
	ipaddr_t localIp;
	ipaddr_t globalIp;
	uint16 localPort, globalPort;
	uint16 endLocalPort, endGlobalPort;
	uint32 asicTablePos;
	uint32 	tcp:1, //Entry for TCP server
			udp:1, //Entry for UDP server
			toAsic:1; //Entry configured to ASIC and asicTablePos is valid when toAsic==1
	SLIST_ENTRY(rtl8651_tblDrv_naptServerPortEntry_s) nextServerPort;
} rtl8651_tblDrv_naptServerPortEntry_t;

#define dmzHostNumInOneSession 3

typedef struct rtl8651DmzHostStruct_s {
	#if 0
	ipaddr_t naptIp;
	ipaddr_t dmzHost;
	#endif
	/* This is for multiple DMZ-host spec */
	ipaddr_t naptIp[dmzHostNumInOneSession];
	ipaddr_t dmzHost[dmzHostNumInOneSession];	
} rtl8651DmzHostStruct_t;


typedef int32 (*alg_funcptr_t)(struct rtl_pktHdr * , struct ip*, struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
typedef struct rtl8651_tblDrv_algEntry_s {
	uint16	startPort, endPort;
	uint32	tcpServer:1,	//The ALG service is providing TCP server service. Trapping internal to external source port and external to internal destination port
			tcpClient:1,	//The ALG service is providing TCP client service. Trapping internal to external destination port and external to internal source port
			udpServer:1,	//The ALG service is providing UDP server service. Trapping internal to external source port and external to internal destination port
			udpClient:1,	//The ALG service is providing UDP client service. Trapping internal to external destination port and external to internal source port

			toAsic:1,	//1: write to ALG Table, 0: merge to ACL table 
	
			fwEngAdd:1; // entry is add by forwarding engine 
			
			
	/* software use internal to external callback */
 	alg_funcptr_t 	alg_outboundClientcb;
 	alg_funcptr_t 	alg_outboundServercb;
 	alg_funcptr_t 	alg_inboundClientcb;
 	alg_funcptr_t 	alg_inboundServercb;
		
	//struct rtl8651_tblDrv_algEntry_s * next;
	SLIST_ENTRY(rtl8651_tblDrv_algEntry_s) nextAlgEntry;
} rtl8651_tblDrv_algEntry_t;

/* software use */
 /* used to save changes to ACK/sequence numbers */
struct l4ack_data_record				  
{
	uint32    ack_old;
	uint32    ack_new;
	int32     delta;
	int32     active;
};
#define L4_N_LINK_TCP_DATA 2




// for hashing
#define NAPT_HASH1  1		// Hash algorithm for index (5-tuple [Int,Rem])
#define NAPT_HASH2  2		// Hash algorithm for index (3-tuple [Int,   ])
#define NAPT_HASH3  3		// Hash algorithm for index (5-tuple [Ext,Rem])

// for connectionType
#define	NAPT_TYPE_NORMAL      0  //This connection is a normal TCP/UDP conenction.
#define NAPT_TYPE_SERVERPORT  1  //This connection is for server port.
                                 //  Note that we don't monitor connection states (SYN/ACK/FIN)
#define NAPT_TYPE_ALG_CONNECTION 3  //This connection is ALG control channel.

typedef struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s {
	ipaddr_t 	insideLocalIpAddr;	//Internal IP
	ipaddr_t 	insideGlobalIpAddr;//External IP
	ipaddr_t 	dstIpAddr;			//Destination IP
	uint16 	insideLocalPort;		//Internal port
	uint16 	insideGlobalPort;	//External port
	uint16 	dstPort;				//Destination port
		
	uint16	alive:1;			//If not alive, this entry has been timed-out. 
	uint16 	tcp:1;				//Connection is TCP
	uint16	hashing:2;			//Type of hashing algorithm used for outbound flow. (ie.NAPT_XXX_HASHING above)
	uint16	tcpFlag:3; 			//Connection's TCP state
	uint16	quiet:1;			//Don't send SYN/FIN/RST segments to software. supported by 8651B ASIC
	uint16	fromDrv:1;			//Whether this entry is generated by driver. Aging by driver (To asic as static)
	                            //Driver means: Forwarding engine. fromDrv==FALSE means from Protocol Stack.
	uint16	col1:1;				// Used only when reading directly from ASIC.
	uint16	col2:1;				// Used only when reading directly from ASIC.
	uint16	isStatic:1;			// Used only when reading directly from ASIC.
	uint16	asicSnapshot:1; 	//Entry is an ASIC snapshot. It really isn't in driver table.
	                            //TRUE means the content of this instance is mirrored from ASIC (maybe different to instance in driver table)
/* Louis commented asicAutoLearnt. It is no use anymore. */
//	uint16	asicAutoLearnt:1;	//Entry was auto learnt by ASIC. Set only by _rtl8651_getNaptEntry() when read directly from ASIC. Useless for software
	uint16	pureSoftware:1;		/* This connection is always handled by software, ex: policy route. NEVER swap to ASIC. */
	uint16	interfaceRoute:1;	/* This connection' dest is interface route, only inbound entry can be ASIC-accelerated. */
	uint16	newlyAddedHash2Udp:1;	/* This connection is newly-added HASH2 UDP, and should not be ASIC-accelerated until PPS>threshold. */
	uint16	holdForCdrouter:1;	/* This connection is newly-added, and we want it stay in software (for CDRouter) until PPS>threshold. */
#ifndef RTL865XB_URL_FILTER
	uint16 	urlFiltered:1;		//For TCP entries only. This flow has been filtered or not
#endif
	uint16	connectionType:2;	//The connection type, possible value:
	uint16	toProtocolStack:1;	/* This connection is for gw <---> remote public. We must trap all packets which match this entry */
	uint16	dosEnCount:1;		/* Check if this flow is conunted in DoS Connection count control system */
	uint16	dosFromInternal:1;	/* Check if this flow is from internal or external interface */

	//uint16	reserved:1;
	/* cchuang added, but Louis commented */
	//uint16	acl_flag:1;			//1: relative to ACL rule
	uint32 	age;				//lifetime remains. in uints of seconds.
	int16 	outboundTblIdx;		//entry index used for outbound flow
	int16   	inboundTblIdx;		//entry index used for inbound flow
	uint32	pps; 		//pkt rcvd per second
	uint16	createTimeStamp; 	//system uptime when connection created.
	uint8	outListType:4; 		//outbound list number, eg. NAPT_ASIC_CACHED,
	uint8	inListType:4;		//inbound list number, eg. NAPT_ASIC_CACHED,
	uint16	selEIdx;			//Nexthop Table Index (hash1)
	                			//inbouind flow (hash2)

	/***********************************************************/
	uint8	tcpStateINdex:4; // tcp ack array index			
	uint8	tcpAckModified:1; // tcp ack number to modify
	uint8	tcpFtpLastLineCRLFTermed:1; // for ftp alg use
	uint8	natlink:1; // for nat link only
	uint8	h245tunnel:1; // for h225 link only

	int32  (*alg_client_in)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
	int32  (*alg_client_out)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
	int32  (*alg_server_in)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
	int32  (*alg_server_out)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
	 /* used to save changes to ACK/sequence numbers */
	struct l4ack_data_record ack[L4_N_LINK_TCP_DATA]; /* ack number */
	/***********************************************************/

	/* Cache routing information */
	void			*out_rt_t; 
	void			*in_rt_t;
	void 		*out_macInfo_t;
	void 		*in_macInfo_t;
	uint8		dsid;
	
	//MUST be continuous 3 fields AND at the END of structure, _rtl8651_delNaptConnection() relies on this... 
	SLIST_ENTRY(rtl8651_tblDrv_naptTcpUdpFlowEntry_s)  nextOut;	//Next outbound entry in chain
	SLIST_ENTRY(rtl8651_tblDrv_naptTcpUdpFlowEntry_s)  nextIn;	//Next inbound entry in chain
	CTAILQ_ENTRY(rtl8651_tblDrv_naptTcpUdpFlowEntry_s)  next;   //link pointer to free list or inuselist
} rtl8651_tblDrv_naptTcpUdpFlowEntry_t;



#define NAPT_ASIC_CACHED_OUT	0	// asic cache 
#define NAPT_ASIC_CACHED_IN		1	// asic cache 

#define NAPT_ALG_OUT			2	// ALG outbound list
#define NAPT_ALG_IN				3	// ALG inbound list

#define NAPT_CANDIDATE_OUT      4	// Candidate Out
#define NAPT_CANDIDATE_IN       5	// Candidate In

#define NAPT_TOTAL_LISTS		8


// FIXME: should be faded out
// function name is changed
#define _rtl8651_addAlgCtrlConnection _rtl8651_addNaptAlgConnection 
#define _rtl8651_delAlgCtrlConnection _rtl8651_delNaptAlgConnection 
#define _rtl8651_getInboundAlgCtrlFlow _rtl8651_getInboundAlgConnection 
#define _rtl8651_getOutboundAlgCtrlFlow _rtl8651_getOutboundAlgConnection 



//cfliu: expand the SLIT_HEAD macro since source insight can't parse it. ugly, I know.
//SLIST_HEAD(naptEntryListHead, rtl8651_tblDrv_naptTcpUdpFlowEntry_s);
struct naptEntryListHead {
	struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *slh_first;	/* first element */	
};


typedef struct rtl8651DrvNaptLine_s {
	uint8 	forcedCollision1:1; //TRUE if software has at least one hash1 based flow in inbound list or outbound list
	uint8 	forcedCollision2:1; //TRUE if software has at least one hash2 based flow in inbound list or outbound list
	struct 	naptEntryListHead list[NAPT_TOTAL_LISTS];
} rtl8651DrvNaptLine_t;  //Each line is one-to-one mapping with an ASIC NAPT line

#if 0
typedef struct {
	uint16 outbound_conns; //number of table entries in 'list' which uses hetrogeneous ID selection algorithm
	uint16 inbound_refCnt; //number of inbound flows which relies on this icmp napt line's collision bit keep set.
	CTAILQ_HEAD(_IcmpNaptLine, rtl8651_tblDrv_naptTcpUdpFlowEntry_s) list; //List of driver table entries hashed on this icmp napt line
} rtl8651DrvIcmpNaptLine_t;  //Each line is one-to-one mapping with an ASIC ICMP NAPT line
#endif

typedef struct rtl8651_tblDrv_naptIcmpFlowEntry_s {
	ipaddr_t insideLocalIpAddr;
	ipaddr_t insideGlobalIpAddr;
	ipaddr_t dstIpAddr;
	uint16 insideLocalId;
	uint16 insideGlobalId;
	uint32 age;//Seconds as unit
	uint16 count;//Number of unanswered query using this translation entry
	//When canAsic is 0 (Unable to forward by ASIC), this index point to the entry position that fill collsion bit for 
	// backward traffic trap to CPU.
	uint32 	staticEntry:1,
			protoDel:1, //Whether protocol stack deletes this entry
			alive:1, //Whether entry alive or not
			toAsic:1,
			fromAsic:1,//Whether this entry is read from ASIC, means insideGlobalIpAddr, dstIpAddr and dstPort unknown
			fromDrv:1,//Whether this entry is generated by driver. Aging by driver (To asic as static)
			canAsic:1;//Whether this translation entry feasible to fill ASIC entry. If not, 

	/* cached informations */
	uint8 dsid;

	//CTAILQ_ENTRY(rtl8651_tblDrv_naptTcpUdpFlowEntry_s)  nextEntry;  //link pointer to next entry on same hash line
	//CTAILQ_ENTRY(rtl8651_tblDrv_naptTcpUdpFlowEntry_s)  next;   //link pointer to free list or inuselist
	struct rtl8651_tblDrv_naptIcmpFlowEntry_s * next;
} rtl8651_tblDrv_naptIcmpFlowEntry_t;

typedef struct rtl8651_tblDrv_serverPortAsicArrangementEntry_s {
	uint16 valid:1;
	rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
} rtl8651_tblDrv_serverPortAsicArrangementEntry_t;

typedef struct rtl8651_tblDrv_algAsicArrangementEntry_s {
	uint16 port;
	uint16 valid:1;
} rtl8651_tblDrv_algAsicArrangementEntry_t;



#define _RTL8651_URLSTRBUFLEN 128

#define RTL865XB_URL_FILTER

/* for further 'per-packet' information filtering */
typedef struct urlPktFiltering_s {
	/* rule type of this filter entry */
	uint32 rule_type;

	/* filter for source IP address range */
	ipaddr_t	sip_start;
	ipaddr_t	sip_end;

	/* filter for source MAC address */
	ether_addr_t smac;

	/* data structure */
	SLIST_ENTRY(urlPktFiltering_s) nextUse;			/* used in urlfiltering linked list */
	SLIST_ENTRY(urlPktFiltering_s) next;			/* used in Inuse/free list*/
} urlPktFiltering_t;

/* for pattern match filtering */
typedef struct urlFiltering_s {
	int32	urlFilterCount;
	uint16 	urlHdrJmpTbl[256]; 						/* Jump Table for string: "\r\n\r\n" */
	uint16 	urlHostJmpTbl[256]; 						/* Jump Table for string: "\r\nHost: " */
	uint16	urlGetJmpTbl[256];						/* Jump Table for string: "GET \" */
	uint16	urlGet1JmpTbl[256];						/* Jump Table for string: "GET http://" */

	int8		urlString[_RTL8651_URLSTRBUFLEN];
	int8		**urlFilterDB;
	uint16	**urlFilterJmpTbl;
	int32	*urlFilterStrLen;
	uint8	*urlExactlyMatch;
	uint32	*sessionId;

	SLIST_HEAD(, urlPktFiltering_s) pktFilter[256];
} urlFiltering_t;

extern urlFiltering_t _urlFilter;


/* idle timeout */

typedef struct rtl8651_pppoeHangUp_s {
	uint32 aging;								/* aging timer for PPPoE hang up */
	uint32 ageTime;
	rtl8651_tblDrv_pppTable_t *pppoe_t;		/* point to PPPoE Instance */
	int32 (*p_handler)(uint32); 				/* call out handler */
	uint32 oldTcpFastTimeout;
	uint32 oldTcpMediumTimeout;
	uint32 oldTcpLongTimeout;
	uint32 oldUdpTimeout;
} rtl8651_pppoeHangUp_t;

typedef struct rtl8651_softpppoeHangUp_s {
	uint32 last_received;
	uint32 last_transmit;
	uint32 idletime_limit;
	rtl8651_tblDrv_pppTable_t *pppoe_t;		/* point to PPPoE Instance */
	int32 (*p_handler)(uint32); 				/* call out handler */
} rtl8651_softpppoeHangUp_t;



/*
 * Macro defined for 4-way hash
 * For example:
 *   int orgi_idx, loop_idx, i;
 *
 *   orig_idx = HASH1( isTcp, IntIp, IntPort, ExtIp, ExtPort );
 *   for( i = 0; i < 4; i++ )
 *   {
 *       loop_idx = WRAPIN_4WAY( orig_idx, i );
 *
 *       ... blah blah, your code is here ...
 *   }
 *
 * Another example:
 *   int idx, i;
 *
 *   idx = HASH1( isTcp, IntIp, IntPort, ExtIp, ExtPort );
 *   for( i = 0; i < 4; i++ )
 *   {
 *       idx = WRAPIN_4WAY( idx, 1 );
 *
 *       ... blah blah, your code is here ...
 *   }
 *
 */
#define WRAPIN_4WAY( idx, inc ) ( (idx&~0x0003) | ((idx+inc)&0x0003) )


#endif /*RTL86561_LAYER4_LOCAL_H*/
#endif /*RTL8651_TBLDRV_LOCAL_H*/
